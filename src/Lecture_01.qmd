---
title: "1. Numerical Integration"
format: html
editor: visual
execute:
  echo: false
  warning: false
  error: false
---

```{r}
library(devtools)
```

```{r}
#| echo: true
#| message: false

install_github("j-buss/RSSim")
library(RSSim)
```

# Numerical Integration

# Chapter 3 - Random Numbers

## 3.1 Pseudorandom number generation

### Multiplicative Congruential Method

Also known as a [Lehmer random number generator](https://en.wikipedia.org/wiki/Lehmer_random_number_generator).

$$
x_n = a x_{n-1} \,\text{mod}\, m
$$

The limits on the parameters are: $0 < x_0 <m$

If we use the values

-   $a = 2$
-   $m = 7$
-   $x_0 = 6$

We have:

|                $X$                 |
|:----------------------------------:|
|              $x_0=6$               |
| $x_1=5=2 \cdot 6 \;\text{mod}\; 7$ |
| $x_2=3=2 \cdot 5 \;\text{mod}\; 7$ |
| $x_3=6=2 \cdot 3 \;\text{mod}\; 7$ |

```{r}
#| echo: True

lehmer.seq
```

```{r}
#| echo: True
#| 
lehmer.seq(x0=6, a=2, m=7, iterations = 10)
```

```{r}
#| echo: True

lehmer.rng
```

```{r}
#| echo: True

lehmer.rng(x0=10, a=9, m=4, iterations=19)
```

#### Mixed Congruential Method

[Linear congruential generator](https://en.wikipedia.org/wiki/Linear_congruential_generator) (LCG):

::: callout-note
INSERT Math formula for LCG
:::

```{r}
#| echo: True

lcg.seq
```

```{r}
#| echo: True 

#lcg.seq()
```

```{r}
#| echo: True

lcg.rng
```

```{r}
#| echo: True

lcg.rng(x0=3, a=5, c=7, m=200)
```

## 3.2 Using Random numbers to Evaluate Integrals

IFunction defined for numerical Integration

```{r}
#| echo: True
#| 
NumIntegration <- function(func, numberOfX) {
  startInt <- (1 / numberOfX)/2
  x <- seq(startInt, 1 - startInt, length.out = numberOfX)
  sum(func(x) * (1/numberOfX))
}
```

#### Function 1:

$$
\int_0^1 e^{(e^x)} dx
$$

If we want to use Monte Carlo Integration with Uniform sampling the easiest integral will be one on the range of 0 to 1.

First we define the function in R:

```{r}
#| echo: true
#| 
f1 <- function(x){exp(exp(x))}
```

Now we calculate the integral using our NumIntegration function. This is utilizing the Reimann midpoint sum.

Here we utilize a very small number of 4 rectangles:

```{r}
NumIntegration(f1, 4)
```

Now use the R function to `integrate`

```{r}
result <- integrate(f1, lower = 0, upper = 1)
# Print the result
print(result)
```

The results are the same.

Now use [Monte Carlo Integration](https://en.wikipedia.org/wiki/Monte_Carlo_integration) using the uniform sampling

```{r}
n <- 10000
sum(f1(runif(n)))/n
```

#### Function 2:

$$
\int_0^1 (1-x^2)^{(3/2)} dx
$$

```{r}
f2 <- function(x){(1-x^2)^(3/2)}
```

```{r}
NumIntegration(f2, 10000)
```

```{r}
result <- integrate(f2, lower = 0, upper = 1)
# Print the result
print(result)
```

Results are the same again. Yeah!

```{r}

sum(f2(runif(n)))/n
```

What about when the limits of integration are different?:

```{r}
NumIntegration2 <- function(func, numberOfX, lowerLimit, upperLimit) {
  startInt <- ((upperLimit - lowerLimit) / numberOfX)/2 + lowerLimit
  x <- seq(startInt, 1 - startInt, length.out = numberOfX)
  sum(func(x) * (1/numberOfX))
}
```

```{r}
upperLimit <- 2
lowerLimit <- -2
numberOfX <- 10
```

```{r}
NumIntegration2 <- function(func, numberOfX, lowerLimit, upperLimit) {
  totalRange <- upperLimit - lowerLimit
  margin <- (totalRange / numberOfX)/2 
  startInt <- margin + lowerLimit
  lastInt <- upperLimit - margin
  x <- seq(startInt, lastInt, length.out = numberOfX)
  sum(func(x) * (totalRange/numberOfX))
}
```

#### Function 3:

$$
\int_{-2}^{2} e^{(x+x^2)} dx
$$

```{r}
f3 <- function(x){exp(x+x^2)}
```

```{r}
NumIntegration2(f3, 10000, -2, 2)
```

```{r}
result <- integrate(f3, lower = -2, upper = 2)
# Print the result
print(result)
```

```{r}
sum(f3(runif(n)))/n
```

Well...that doesn't look right. Why doesn't our Monte Carlo integration work with this integral? The limits are incorrect. Our Monte Carlo integration is assumed to be on the range from 0 to 1. Instead this integral is defined from -2 to 2. We need to modify our Monte Carlo Integration a bit.

Change of variable:

If we want $\theta = \int_a^b g(x)dx$ then we do a change of variable:

$$y = \frac{x-a}{b-a}$$

Which gives us

$$\frac{dy}{dx} = \frac{1}{b-a} \; \text{or} \; dy(b-a)=dx$$

Then we have $x=y(b-a)+a$

y = x/4 + 1/2

h(y) = (2 - -2)g(-2 + 4y)=4 g(4y-2)

```{r}
n <- 100000
f3b <- function(x){4*exp((4*x - 2)+(4*x - 2)^2)}
sum(f3b(runif(n)))/n
```

What about integrals that have an Infinity for the bounds?

#### Function 4:

$$
\int_{0}^{\infty} x * (1 + x^2)^{-2} dx
$$

```{r}
f4 <- function(x){x * (1 + x^2)^(-2)}
```

```{r}
integrate(f4, 0, Inf)
```

```{r}
NumIntegration3 <- function(func, numberOfX, lowerLimit, upperLimit) {
  bigInt = 1000
  if (upperLimit == "Inf") {upperLimit = 1 * bigInt}
  if (lowerLimit == "-Inf") {lowerLimit = -1 * bigInt}
  totalRange <- upperLimit - lowerLimit
  margin <- (totalRange / numberOfX)/2 
  startInt <- margin + lowerLimit
  lastInt <- upperLimit - margin
  x <- seq(startInt, lastInt, length.out = numberOfX)
  sum(func(x) * (totalRange/numberOfX))
}
```

```{r}
NumIntegration3(f4, 100000, lowerLimit = 0, upperLimit = Inf)
```

```{r}
sum(f4(runif(n)))/n
```

```{r}
f4b <- function(x){((1 - x)/x^3)/(1/x^2 - 2/x + 2)^2}
sum(f4b(runif(n)))/n
```

#### Function 5:

$$
\int_{-\infty}^{\infty} e^{-x^2} dx
$$

```{r}
f5 <- function(x){exp(-1*(x^2))}
```

```{r}
NumIntegration3(f5, 100000, lowerLimit = -Inf, upperLimit = Inf)
```

```{r}
result <- integrate(f5, lower = -Inf, upper = Inf)
# Print the result
print(result)
```
